<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dimitri's Blog</title>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>MathJax = { "tex": { "inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]] }, "svg": { "fontCache": "global" } }</script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <link rel="stylesheet" href="smith.css">
    <!-- Local-file fallbacks in case fetch() is blocked (file://) -->
    <script id="posts-json" type="application/json">
[
    {
        "title": "Sphere Packing",
        "filename": "post8.md",
        "date": "2025-3-19",
        "author": "Post 7",
        "bio": "How to pack spheres into your 3d model",
        "categories": ["Computer"]
    },
    {
        "title": "Small Physics Sim For Balls",
        "filename": "post7.md",
        "date": "2025-2-25",
        "author": "Post 7",
        "bio": "Playing around with a balls in verlet integration",
        "categories": ["Computer Graphics", "Physics"]
    },
    {
        "title": "Cool Complex Shapes",
        "filename": "post6.md",
        "date": "2025-1-19",
        "author": "Post 6",
        "bio": "Mandelebulb, Julia set, Kleinian limit set-Maskit, Newton's Fractal",
        "categories": ["Mathematics"]
    },
    {
        "title": "Graphing Some English Words",
        "filename": "post5.md",
        "date": "2025-1-6",
        "author": "Post 5",
        "bio": "Making cool graphs with some words",
        "categories": ["Graph Theory"]
    },
    {
        "title": "Solving a Polynomial",
        "filename": "post4.md",
        "date": "2025-1-3",
        "author": "Post 4",
        "bio": "How to find roots of a polynomial",
        "categories": ["Mathematics"]
    },
    {
        "title": "Blending Spheres",
        "filename": "post3.md",
        "date": "2024-12-26",
        "author": "Post 3",
        "bio": "How to blend spheres together",
        "categories": ["Mathematics", "Computer"]
    },
    {
        "title": "Fourier Fun",
        "filename": "post2.md",
        "date": "2024-12-20",
        "author": "Post 2",
        "bio": "A fun little dive into Fourier series, its coefficients, and applications in animation.",
        "categories": ["Mathematics"]
    },
    {
        "title": "0.0.0 Post!!",
        "filename": "post1.md",
        "date": "2024-12-19",
        "author": "Post 1",
        "bio": "git commit 'intial commit' --> git push -u origin main\n",
        "categories": ["Fun"]
    }
]
    </script>
    <script id="colors-json" type="application/json">
{
    "Mathematics": "darkblue",
    "Fun": "red",
    "Blog": "green",
    "First": "orange",
    "Science": "purple",
    "Technology": "teal",
    "Art": "pink",
    "Education": "yellow",
    "Computer": "purple",
    "Graph Theory": "teal",
    "Physics": "orange"
}
    </script>
</head>

<body>
    <div id="scene-container"></div>
    <div id="canvas-container"></div>
    <header class="header">
        <div class="header-content">
            <h1 class="header-title">Dimitri's Blog</h1>
            <div class="header-subtitle"> This is not nearly a complete repository of all my projects. I purely write
                things here for fun</div>
        </div>
    </header>

    <main class="content">
        <div id="main-content"></div>
    </main>

    <!-- Local-file fallback: inline markdown for post8 -->
    <script id="post-post8.md" type="text/markdown">
# Sphere Packing inside Arbitrary Meshes
### SRC: [https://github.com/DimitriChrysafis/SpherePacking](https://github.com/DimitriChrysafis)

## Demos

<br />

### 1. The Stanford Bunny

Links: <a href="../media/post8/dragon.html" target="_blank" rel="noopener noreferrer">Dragon</a> | <a href="../media/post8/ogre.html" target="_blank" rel="noopener noreferrer">Ogre</a>

<br />
<br />

<div style="position: relative; width: 100%; padding-bottom: 56.25%; height: 0;">
  <iframe 
    src="../media/post8/bunny.html" 
    style="position: absolute; top:0; left:0; width:100%; height:100%; border:none;"
    scrolling="no">
  </iframe>
</div>

<br />
<br />
<br />


## KEY IDEA HOW IT WORKS:

To tightly pack spheres inside an arbitrary 3D mesh, we use a hybrid approach combining GPU-accelerated grid search for initial placement and a stochastic tangent-based purely iterative solver for filling gaps. All geometric queries invoke custom CUDA/MPS kernels for high-throughput ray-triangle intersection tests.


<br />
<br />
<br />


## GPU Intersection

<br />

Point containment is determined via the Generalized Winding Number or simple Ray Casting (Parity Rule) for watertight meshes.

<br />

<div>
$$
\text{Inside}(P) \iff \left( \sum_{T \in \text{Mesh}} \text{Intersect}(P, \vec{d}, T) \right) \equiv 1 \pmod 2
$$
</div>

<br />

We solve for intersection time $t$ and barycentric coordinates $(u, v)$ against triangle vertices $V_0, V_1, V_2$. This is a change of basis problem mapping the ray space to the triangle's barycentric space.

<br />

<div>
$$
\vec{P} = \vec{O} + t\vec{D} = (1 - u - v)V_0 + uV_1 + vV_2
$$
</div>

<br />

Rearranging into a linear system $Ax = b$:

<br />

<div>
$$
\begin{bmatrix}
-\vec{D} & V_1 - V_0 & V_2 - V_0
\end{bmatrix}
\begin{bmatrix}
t \\ u \\ v
\end{bmatrix}
= \vec{O} - V_0
$$
</div>

<br />

Using Cramer's Rule (Möller–Trumbore algorithm), we define the edge vectors and determinants:

<br />

<div>
$$
\begin{aligned}
\vec{E}_1 &= V_1 - V_0 \\
\vec{E}_2 &= V_2 - V_0 \\
\vec{T} &= \vec{O} - V_0 \\
\vec{P} &= \vec{D} \times \vec{E}_2 \\
\vec{Q} &= \vec{T} \times \vec{E}_1
\end{aligned}
$$
</div>

<br />

The solution for $t$ is then given by the ratio of determinants:

<br />

<div>
$$
t = \frac{\det(\vec{T}, \vec{E}_1, \vec{E}_2)}{\det(-\vec{D}, \vec{E}_1, \vec{E}_2)} = \frac{1}{\vec{P} \cdot \vec{E}_1} (\vec{Q} \cdot \vec{E}_2)
$$
</div>


<br />
<br />
<br />


## Grid Search

<br />

To find the largest possible sphere in standard space, we discretize the bounding volume into a high-resolution grid $G$. This acts as a global optimization step to escape local optima that a purely greedy approach might fall into.

<br />

<div>
$$
G_{ijk} \in \mathbb{R}^3 \cap \Omega_{mesh}
$$
</div>

<br />

For every valid grid point, we compute the nearest distance to the surface point cloud $S$. This is effectively computing the Signed Distance Function (SDF) on the GPU:

<br />

<div>
$$
\text{SDF}(p) = \min_{s \in S} ||p - s||
$$
</div>

<br />

<div>
$$
R_{max} = \max_{p \in G} (\text{SDF}(p))
$$
</div>

<br />

This provides the optimal starting seed for the packing algorithm.


<br />
<br />
<br />


## Tangent Solver

<br />

Subsequent spheres are placed by expanding from the surface of existing spheres. This ensures tight packing density ($\phi_{local} \approx 0.74$).

<br />

Given an anchor sphere $(C_a, r_a)$ and a random direction $\hat{d}$, the new sphere center is parameterized by its radius $r$:

<br />

<div>
$$
C_{new}(r) = C_a + (r_a + r) \hat{d}
$$
</div>

<br />

We find the maximum valid $r$ using a **Binary Search** over the interval $[0, R_{max}]$.

<br />

### Binary Search Logic

<br />

<div>
$$
\begin{array}{c}
\text{Start Interval: } [L, H] \\
\downarrow \\
\text{Midpoint: } m = \frac{L+H}{2} \\
\downarrow \\
\text{Check Validity}(C_{new}(m), m) \\
\swarrow \qquad \searrow \\
\text{Valid} \qquad \text{Invalid} \\
L \leftarrow m \qquad H \leftarrow m
\end{array}
$$
</div>

<br />

The validity check $\text{Valid}(C, r)$ involves three simultaneous constraints:

<br />

### 1. Mesh Containment

The sphere must remain entirely inside the mesh.

<br />

<div>
$$
\text{Inside}(C) \land (\text{SDF}(C) \ge r)
$$
</div>

<br />

### 2. Surface Clearance

The sphere cannot penetrate the mesh boundary.

<br />

<div>
$$
r \le \min_{s \in S} ||C - s||
$$
</div>

<br />

### 3. Mutual Exclusion

The sphere cannot overlap with any existing sphere $i$.

<br />

<div>
$$
\forall i: ||C - C_i|| \ge r + r_i
$$
</div>
    </script>

    <br />
    <br />
    <br />


    ## KEY IDEA HOW IT WORKS:

    To tightly pack spheres inside an arbitrary 3D mesh, we use a hybrid approach combining GPU-accelerated grid search
    for initial placement and a stochastic tangent-based purely iterative solver for filling gaps. All geometric queries
    invoke custom CUDA/MPS kernels for high-throughput ray-triangle intersection tests.


    <br />
    <br />
    <br />


    ## GPU Intersection

    <br />

    Point containment is determined via the Generalized Winding Number or simple Ray Casting (Parity Rule) for
    watertight meshes.

    <br />

    <div>
        $$
        \text{Inside}(P) \iff \left( \sum_{T \in \text{Mesh}} \text{Intersect}(P, \vec{d}, T) \right) \equiv 1 \pmod 2
        $$
    </div>

    <br />

    We solve for intersection time $t$ and barycentric coordinates $(u, v)$ against triangle vertices $V_0, V_1, V_2$:

    <br />

    <div>
        $$
        \vec{P} = \vec{O} + t\vec{D} = (1 - u - v)V_0 + uV_1 + vV_2
        $$
    </div>

    <br />

    Rearranging into a linear system:

    <br />

    <div>
        $$
        \begin{bmatrix}
        -\vec{D} & V_1 - V_0 & V_2 - V_0
        \end{bmatrix}
        \begin{bmatrix}
        t \\ u \\ v
        \end{bmatrix}
        = \vec{O} - V_0
        $$
    </div>

    <br />

    Using Cramer's Rule (Möller–Trumbore algorithm):

    <br />

    <div>
        $$
        \begin{aligned}
        \vec{E}_1 &= V_1 - V_0 \\
        \vec{E}_2 &= V_2 - V_0 \\
        \vec{T} &= \vec{O} - V_0 \\
        \vec{P} &= \vec{D} \times \vec{E}_2 \\
        \vec{Q} &= \vec{T} \times \vec{E}_1
        \end{aligned}
        $$
    </div>

    <br />

    <div>
        $$
        t = \frac{1}{\vec{P} \cdot \vec{E}_1} (\vec{Q} \cdot \vec{E}_2)
        $$
    </div>


    <br />
    <br />
    <br />


    ## Grid Search

    <br />

    To find the largest possible sphere in standard space, we discretize the bounding volume into a high-resolution grid
    $G$.

    <br />

    <div>
        $$
        G_{ijk} \in \mathbb{R}^3 \cap \Omega_{mesh}
        $$
    </div>

    <br />

    For every valid grid point, we compute the nearest distance to the surface point cloud $S$:

    <br />

    <div>
        $$
        R_{max} = \max_{p \in G} \left( \min_{s \in S} ||p - s|| \right)
        $$
    </div>

    <br />

    This provides the optimal starting seed for the packing algorithm.


    <br />
    <br />
    <br />


    ## Tangent Solver

    <br />

    Subsequent spheres are placed by expanding from the surface of existing spheres.

    <br />

    Given an anchor sphere $(C_a, r_a)$ and a random direction $\hat{d}$:

    <br />

    <div>
        $$
        C_{new}(r) = C_a + (r_a + r) \hat{d}
        $$
    </div>

    <br />

    We perform a bisection search to maximize radius $r$ subject to three constraints:

    <br />

    ### 1. Mesh Containment

    <br />

    <div>
        $$
        \text{Inside}(C_{new}(r)) = \text{True}
        $$
    </div>

    <br />

    ### 2. Surface Clearance

    <br />

    <div>
        $$
        r \le \min_{s \in S} ||C_{new}(r) - s||
        $$
    </div>

    <br />

    ### 3. Mutual Exclusion

    <br />

    <div>
        $$
        ||C_{new}(r) - C_existing|| \ge r + r_{existing}
        $$
    </div>
    </script>
    <script id="post-post7.md" type="text/markdown">
# Physics-Based Particle Simulations: A Deep Dive
### SRC: [https://github.com/DimitriChrysafis/BallDrawer](https://github.com/DimitriChrysafis/BallDrawer)


## Verlet Integration Demonstrations

<video width="1000" controls autoplay muted>  
  <source src="../media/post7/initial.mp4" type="video/mp4">  
  Your browser does not support the video tag.  
</video>


<br />
<br />


<div style="position: relative; width: 100%; padding-bottom: 56.25%; height: 0;">
  <iframe 
    width="100%" 
    height="500" 
    src="https://www.youtube.com/embed/Gz6gZwLvjaw" 
    frameborder="0" 
    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" 
    allowfullscreen> 
  </iframe> 
</div>


<br />
<br />
<br />


## KEY IDEA HOW IT WORKS:

Before each video is recorded, a complete physics simulation runs with predefined parameters. All particles begin as uniform red balls, which later map to colors from a target image. This document provides a comprehensive explanation of the mathematical foundations and implementation details powering these simulations.


<br />
<br />
<br />


## How Verlet Integration Works

<br />

The system evolves without explicit velocity tracking, relying entirely on position history.

<br />

<div>
$$
\begin{align*}
\text{State}_t &= \{ \vec{x}_t, \vec{x}_{t-\Delta t}, \vec{a}_t \} \\
\downarrow \\
\vec{x}_{t+\Delta t} &= 2\vec{x}_t - \vec{x}_{t-\Delta t} + \vec{a}_t \Delta t^2
\end{align*}
$$
</div>

<br />
<br />

### Formal derivation from Taylor Series

<br />

We expand position $\vec{x}$ forward and backward in time around $t$:

<br />

<div>
$$
\begin{cases} 
\vec{x}(t+\Delta t) &= \vec{x}(t) + \vec{v}(t)\Delta t + \frac{1}{2}\vec{a}(t)\Delta t^2 + \frac{1}{6}\vec{b}(t)\Delta t^3 + \mathcal{O}(\Delta t^4) \\
\vec{x}(t-\Delta t) &= \vec{x}(t) - \vec{v}(t)\Delta t + \frac{1}{2}\vec{a}(t)\Delta t^2 - \frac{1}{6}\vec{b}(t)\Delta t^3 + \mathcal{O}(\Delta t^4)
\end{cases}
$$
</div>

<br />

Summing the system cancels odd-order terms (Velocity $\vec{v}$ and Jerk $\vec{b}$):

<br />

<div>
$$
\vec{x}(t+\Delta t) + \vec{x}(t-\Delta t) = 2\vec{x}(t) + \vec{a}(t)\Delta t^2 + \mathcal{O}(\Delta t^4)
$$
</div>

<br />

Rearranging for the next state $\vec{x}(t+\Delta t)$:

<br />

<div>
$$
\boxed{\vec{x}_{next} = 2\vec{x}_{curr} - \vec{x}_{prev} + \vec{a}_{curr} \Delta t^2}
$$
</div>

<br />
<br />

### Impulse-Based Velocity approximation

While velocity is implicit, it can be approximated for damping or friction:

<br />

<div>
$$
\vec{v}_t \approx \frac{\vec{x}_t - \vec{x}_{t-\Delta t}}{\Delta t}
$$
</div>


<br />
<br />
<br />


## Temporal Stability

<br />

To maintain simpler collision logic at high speeds, we perform temporal supersampling.

<br />

<div>
$$
\Delta T_{frame} = \frac{1}{60}s
$$
</div>

<br />

<div>
$$
\text{Substeps } N = 8
$$
</div>

<br />

<div>
$$
\Delta t = \frac{\Delta T_{frame}}{N} \approx 2.08 \text{ms}
$$
</div>

<br />

This ensures that particle displacement per step is smaller than the particle radius, preventing tunneling.

<br />

<div>
$$
|\Delta \vec{x}|_{max} < r_{particle}
$$
</div>

<br />
<br />
<br />


## Collision Response

<br />

Collision handling acts as a position constraint solver.

<br />

### 1. Separation Vector Analysis

For any two particles $i$ and $j$:

<br />

<div>
$$
\vec{\delta}_{ij} = \vec{x}_j - \vec{x}_i
$$
</div>

<br />

<div>
$$
d_{ij} = ||\vec{\delta}_{ij}||
$$
</div>

<br />

### 2. Constraint Violation Check

We check if the distance is less than the sum of radii:

<br />

<div>
$$
C(\vec{x}_i, \vec{x}_j) = d_{ij} - (r_i + r_j) < 0
$$
</div>

<br />

### 3. Position Correction (Projection)

If $C < 0$, we resolve by projecting particles out of the collision manifold along the normal $\hat{n}$.

<br />

<div>
$$
\hat{n} = \frac{\vec{\delta}_{ij}}{d_{ij}}
$$
</div>

<br />

The total penetration depth is $P = (r_i + r_j) - d_{ij}$.

We distribute this correction equally (assuming equal mass):

<br />

<div>
$$
\Delta \vec{x}_i = -\frac{P}{2} \hat{n}
$$
</div>

<br />

<div>
$$
\Delta \vec{x}_j = +\frac{P}{2} \hat{n}
$$
</div>

<br />

<div>
$$
\begin{bmatrix}
\vec{x}_i' \\
\vec{x}_j'
\end{bmatrix}
=
\begin{bmatrix}
\vec{x}_i \\
\vec{x}_j
\end{bmatrix}
+
\begin{bmatrix}
-0.5 P \hat{n} \\
+0.5 P \hat{n}
\end{bmatrix}
$$
</div>


<br />
<br />
<br />


## Spatial Hashing

<br />

Naive $O(N^2)$ checks are computationally prohibitive. We map the continuous simulation domain $\Omega \in \mathbb{R}^2$ to a discrete grid space $\mathbb{Z}^2$.

<br />

### Grid Basis

<br />

<div>
$$
\mathcal{G}_{size} = 2 \cdot r_{max} + \epsilon
$$
</div>

<br />

### Discrete Mapping Function

<br />

<div>
$$
H(\vec{x}) : \mathbb{R}^2 \rightarrow \mathbb{Z}^2
$$
</div>

<br />

<div>
$$
H(x, y) = \left( \left\lfloor \frac{x}{\mathcal{G}_{size}} \right\rfloor, \left\lfloor \frac{y}{\mathcal{G}_{size}} \right\rfloor \right)
$$
</div>

<br />

### Adjacency Search

For a particle in cell $(u, v)$, we only compute constraints against set $S_{local}$:

<br />

<div>
$$
S_{local} = \bigcup_{i=-1}^{1} \bigcup_{j=-1}^{1} \text{Cell}(u+i, v+j)
$$
</div>

<br />

This reduces the complexity regime from Quadratic to Linear:

<br />

<div>
$$
\mathcal{O}(N^2) \rightarrow \mathcal{O}(N)
$$
</div>

<br />
    </script>

    <!-- Local-file fallback: inline markdown for post3 -->
    <script id="post-post3.md" type="text/markdown">
# Smooth Blending of Spheres

<video width="1000" controls autoplay muted loop>  
  <source src="../media/post3/blubblubblub.mp4" type="video/mp4">  
  Your browser does not support the video tag.  
</video>  


<br />
<br />
<br />


## SDF Basics  

<br />

The Signed Distance Function (SDF) $d(\mathbf{p})$ maps a point in space to its distance from a surface.

<br />

<div>
$$
\begin{cases} 
d(\mathbf{p}) > 0 & \text{outside} \\
d(\mathbf{p}) = 0 & \text{surface} \\
d(\mathbf{p}) < 0 & \text{inside}
\end{cases}
$$
</div>

<br />

For a sphere $S = \{\mathbf{c}, r\}$:

<br />

<div>
$$
d(\mathbf{p}) = \|\mathbf{p} - \mathbf{c}\| - r
$$
</div>


<br />
<br />
<br />


## Smooth Union

<br />

Standard constructive solid geometry (CSG) uses $\min(d_1, d_2)$ for union, creating sharp creases. To blend smoothly, we use a polynomial mix factor $h$.

<br />

<div>
$$
h = \text{clamp}\left( 0.5 + 0.5 \frac{d_2 - d_1}{k}, 0, 1 \right)
$$
</div>

<br />

<div>
$$
d_{\text{blend}} = \text{mix}(d_1, d_2, h) - k \cdot h(1 - h)
$$
</div>

<br />

The term $k$ controls the Lipschitz continuity of the blend. As $k \to 0$, $d_{\text{blend}} \to \min(d_1, d_2)$.

<br />

<div>
$$
\lim_{k \to 0} \text{SmoothUnion}(d_1, d_2, k) = \text{Union}(d_1, d_2)
$$
</div>


<br />
<br />
<br />


## Material Interpolation

<br />

Physical properties such as albedo, roughness, or metallic factors can be interpolated using the same blend weight $h$.

<br />

<div>
$$
\text{Mat}_{rgb} = (1-h)\text{Mat}_1 + h\text{Mat}_2
$$
</div>


<br />
<br />
<br />


## Visualizations

<br />

<video width="1000" controls autoplay muted loop>  
  <source src="../media/post3/miniblub.mp4" type="video/mp4">  
  Your browser does not support the video tag.  
</video>
    </script>

    <script src="bob.js"></script>
</body>

</html>
