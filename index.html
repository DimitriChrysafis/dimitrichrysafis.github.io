<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dimitri's Blog</title>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["$","$"],["\\(","\\)"]],
          displayMath: [["$$","$$"],["\\[","\\]"]]
        },
        svg: { fontCache: "global" }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <link rel="stylesheet" href="smith.css">
    <!-- Local-file fallback data for when fetch() is blocked (file://). -->
    <script id="posts-json" type="application/json">
[
    {
        "title": "Sphere Packing",
        "filename": "post8.md",
        "date": "2025-3-19",
        "author": "Post 7",
        "bio": "How to pack spheres into your 3d model",
        "categories": ["Computer"]
    },
    {
        "title": "Small Physics Sim For Balls",
        "filename": "post7.md",
        "date": "2025-2-25",
        "author": "Post 7",
        "bio": "Playing around with a balls in verlet integration",
        "categories": ["Computer Graphics", "Physics"]
    },
    {
        "title": "Cool Complex Shapes",
        "filename": "post6.md",
        "date": "2025-1-19",
        "author": "Post 6",
        "bio": "Mandelebulb, Julia set, Kleinian limit set-Maskit, Newton's Fractal",
        "categories": ["Mathematics"]
    },
    {
        "title": "Graphing Some English Words",
        "filename": "post5.md",
        "date": "2025-1-6",
        "author": "Post 5",
        "bio": "Making cool graphs with some words",
        "categories": ["Graph Theory"]
    },
    {
        "title": "Solving a Polynomial",
        "filename": "post4.md",
        "date": "2025-1-3",
        "author": "Post 4",
        "bio": "How to find roots of a polynomial",
        "categories": ["Mathematics"]
    },
    {
        "title": "Blending Spheres",
        "filename": "post3.md",
        "date": "2024-12-26",
        "author": "Post 3",
        "bio": "How to blend spheres together",
        "categories": ["Mathematics", "Computer"]
    },
    {
        "title": "LaTeX Now Works",
        "filename": "post2.md",
        "date": "2024-12-20",
        "author": "Post 2",
        "bio": "A fun little dive into Fourier series, its coefficients, and applications in animation.",
        "categories": ["Mathematics"]
    },

    {
        "title": "0.0.0 Post!!",
        "filename": "post1.md",
        "date": "2024-12-19",
        "author": "Post 1",
        "bio": "git commit 'intial commit' --> git push -u origin main\n",
        "categories": ["Fun"]
    }
]
    </script>
    <script id="colors-json" type="application/json">
{
    "Mathematics": "darkblue",
    "Fun": "red",
    "Blog": "green",
    "First": "orange",
    "Science": "purple",
    "Technology": "teal",
    "Art": "pink",
    "Education": "yellow",
    "Computer": "purple",
    "Graph Theory": "teal",
    "Physics": "orange",
    "WebGPU": "steelblue"
}
    </script>
  </head>
  <body>
    <div id="scene-container"></div>
    <div id="canvas-container"></div>
    <header class="header">
        <div class="header-content">
            <h1 class="header-title">Dimitri's Blog</h1>
            <div class="header-subtitle"> This is not nearly a complete repository of all my projects. I purely write things here for fun</div>
        </div>
    </header>

    <main class="content">
        <div id="main-content"></div>
    </main>

    <!-- Local-file fallback: inline markdown for post9 -->
    <script id="post-deleted-post9" type="text/markdown">
# 3D Volumetric Fluid Simulator (WebGPU + MLS‑MPM)

<div style="position: relative; width: 100%; padding-bottom: 56.25%; height: 0;">
  <iframe 
    width="100%" 
    height="100%" 
    style="position:absolute; top:0; left:0; border:0;"
    src="https://dimitrichrysafis.github.io/media/misc/fluidemo/index.html" 
    allowfullscreen>
  </iframe>
</div>

<br />

This project is a GPU‑accelerated 3D fluid simulator that runs in the browser using WebGPU. It uses a grid‑based particle method (MLS‑MPM) to simulate highly detailed liquid motions with hundreds of thousands of particles, and renders them efficiently as screen‑space spheres with optional wireframe and bounding‑box overlays. Everything — simulation, culling, and rendering — happens on the GPU.

---

## Highlights

- WebGPU compute + render pipeline end‑to‑end (no WebGL fallbacks)
- MLS‑MPM simulation with P2G, grid solve, G2P passes
- Frustum culling on GPU to skip off‑screen particles
- Instanced screen‑space spheres or wireframe rendering
- Live controls (pause, substeps, particle injection, moving wall, camera modes)

<br />

## Demo + Source

- Live demo: https://dimitrichrysafis.github.io/media/misc/fluidemo/index.html
- Repo: https://github.com/DimitriChrysafis/3d-Volumetric-Fluid-Simulator

<br />

## Simulation Overview

The core is an MLS‑MPM loop split across compute pipelines:

1) Clear grid (zero mass, momentum, and auxiliaries)
2) P2G‑1: scatter particle state to nearby grid nodes (weights from quadratic B‑splines)
3) P2G‑2: finalize per‑node values and apply constitutive terms (stiffness, viscosity)
4) Update grid: apply external forces and boundary handling, integrate grid velocities
5) G2P: gather updated grid velocities back to particles and advect

Each stage is a WGSL compute shader bound to the same buffers, dispatched over either particles or grid cells. Time integration supports configurable substeps to stabilize fast motion.

<br />

## Continuum Model (What We’re Discretizing)

We start from the compressible Navier–Stokes equations (mass and momentum conservation):

Mass conservation (continuity):
$$
\frac{\partial \rho}{\partial t} + \nabla\cdot(\rho\,\mathbf{v}) = 0.
$$

Momentum conservation:
$$
\rho\,\frac{\mathrm{D}\mathbf{v}}{\mathrm{D}t} = \nabla\cdot\boldsymbol{\sigma} + \rho\,\mathbf{g},\qquad \frac{\mathrm{D}}{\mathrm{D}t} = \frac{\partial}{\partial t} + (\mathbf{v}\cdot\nabla).
$$

For a Newtonian fluid, the Cauchy stress is
$$
\boldsymbol{\sigma} = -p\,\mathbf{I} + \mu\left(\nabla\mathbf{v} + (\nabla\mathbf{v})^{\!T}\right),
$$
where \(p\) is pressure and \(\mu\) is dynamic viscosity.

To keep things simple and fully GPU‑friendly, we use a weakly compressible equation of state (EOS)
$$
p = k\,(\rho - \rho_0),
$$
with stiffness \(k\) and rest density \(\rho_0\). The associated acoustic speed is \(c \approx \sqrt{k/\rho_0}\), which appears in the CFL condition below.

<br />

## From PDEs to MPM (Weak Form → Particles + Grid)

Material is represented by particles \(p\) carrying \(m_p,\ \mathbf{x}_p,\ \mathbf{v}_p,\ V_p,\ \rho_p\). We place a regular background grid with nodes \(i\) at positions \(\mathbf{x}_i\) and use shape functions \(N_i(\mathbf{x})\) (quadratic B‑splines) to transfer between particles and grid. The weak form of momentum leads to the standard MPM updates:

- Grid mass:
$$ m_i = \sum_p m_p\,N_i(\mathbf{x}_p). $$

- Grid momentum (PIC part + internal forces from stress):
$$
\mathbf{p}_i^{\,\text{new}} = \sum_p N_i(\mathbf{x}_p)\,m_p\,\mathbf{v}_p\;\; -\; \Delta t\sum_p V_p\,\boldsymbol{\sigma}_p\,\nabla N_i(\mathbf{x}_p).
$$

Then grid velocities are \(\mathbf{v}_i = \mathbf{p}_i^{\,\text{new}}/m_i\) (for \(m_i>0\)), body forces like gravity add \(\Delta t\,\mathbf{g}\) to \(\mathbf{v}_i\), and boundary conditions clamp/reflect velocities at the box.

Finally, we bring updated velocities back to particles and advect:
$$
\mathbf{v}_p^{\,\text{new}} = \sum_i N_i(\mathbf{x}_p)\,\mathbf{v}_i,\qquad \mathbf{x}_p^{\,\text{new}} = \mathbf{x}_p + \Delta t\,\mathbf{v}_p^{\,\text{new}}.
$$

<br />

## MLS‑MPM / APIC Affine Velocity (Less Dissipation)

Pure PIC loses vorticity. We therefore augment particle velocities by an affine term so that local linear velocity variation is captured. A standard APIC/MLS update computes an affine matrix \(\mathbf{C}_p\) such that locally
$$
\mathbf{v}(\mathbf{x}) \approx \mathbf{v}_p + \mathbf{C}_p(\mathbf{x}-\mathbf{x}_p).
$$
Given grid velocities, we estimate \(\mathbf{C}_p\) by a least‑squares fit:
$$
\mathbf{B}_p = \sum_i N_i(\mathbf{x}_p)\,\mathbf{v}_i\,(\mathbf{x}_i-\mathbf{x}_p)^{\!T},\qquad
\mathbf{D}_p = \sum_i N_i(\mathbf{x}_p)\,(\mathbf{x}_i-\mathbf{x}_p)(\mathbf{x}_i-\mathbf{x}_p)^{\!T},\qquad
\mathbf{C}_p = \mathbf{B}_p\,\mathbf{D}_p^{-1}.
$$
In practice on a regular grid with quadratic B‑splines, \(\mathbf{D}_p\) has a nearly constant form and we use the standard APIC closed‑form factor (often written with a \(\tfrac{4}{\Delta x^2}\) scale). On P2G, particle momentum contributions include the affine piece \(m_p\,\mathbf{C}_p(\mathbf{x}_i-\mathbf{x}_p)\,N_i\), greatly reducing numerical diffusion.

<br />

## Quadratic B‑Spline Weights and Gradients

We use separable quadratic B‑splines. In 1D with grid spacing \(\Delta x\) and normalized coordinate \(a=\tfrac{x- x_i}{\Delta x}\):
$$
w_0(a)=\tfrac{1}{2}(1.5-a)^2\ \ (0.5\le a<1.5),\qquad
w_1(a)=0.75-a^2\ \ (|a|<0.5),\qquad
w_2(a)=\tfrac{1}{2}(a-1.5)^2\ \ (0.5\le a<1.5),
$$
and \(w_k=0\) otherwise. In 3D, \(N_i(\mathbf{x}_p)=w_{\alpha}(a_x)\,w_{\beta}(a_y)\,w_{\gamma}(a_z)\) for the 27 stencil nodes. The gradient is a product rule of 1D derivatives, e.g.
$$
\nabla N_i(\mathbf{x}_p) = \frac{1}{\Delta x}\Big( w'_\alpha(a_x)\,w_\beta(a_y)\,w_\gamma(a_z),\; w_\alpha(a_x)\,w'_\beta(a_y)\,w_\gamma(a_z),\; w_\alpha(a_x)\,w_\beta(a_y)\,w'_\gamma(a_z) \Big).
$$

These weights preserve linear momentum and provide smooth transfers.

<br />

### Interactive: 3×3×3 B‑spline Stencil

<iframe src="media/post9/stencil.html" width="100%" height="420" style="border:0"></iframe>

<br />

## Pressure and Viscosity on the Grid

- Equation of state (weakly compressible):
$$ p_p = k\,(\rho_p-\rho_0),\qquad \rho_p = \frac{m_p}{V_p}. $$
Internal forces in the momentum update use \(\boldsymbol{\sigma}_p = -p_p\,\mathbf{I} + \mu(\nabla\mathbf{v} + \nabla\mathbf{v}^{\!T})\). The pressure part appears in the P2G force via \(-\,\Delta t\,V_p\,\boldsymbol{\sigma}_p\,\nabla N_i\).

- Viscosity: for a Newtonian fluid with kinematic viscosity \(\nu=\mu/\rho\), a discrete Laplacian smoothing step on the grid approximates
$$ \partial_t\,\mathbf{v} = \nu\,\nabla^2\mathbf{v}. $$
In practice we apply a few Jacobi/explicit diffusion steps or fold it into the grid update shader with the coefficient `dynamic_viscosity`.

<br />

## Boundary Conditions and CFL Stability

- Box walls enforce a no‑penetration condition (and nearly no‑slip): set normal velocity to zero when a node lies on a wall; tangential components can be damped. Particles are clamped to stay inside the domain after advection.

- The moving wall uses a time‑varying box depth
$$ L_z(t) = L_{z0}\bigl(1 + A\,\sin(\omega t)\bigr), $$
and we rebuild the effective collision planes each frame so particles reflect off the animated boundary.

- Stability (CFL): choose \(\Delta t\) such that
$$
\Delta t \;\lesssim\; C\,\frac{\Delta x}{\max\limits_p\bigl(\|\mathbf{v}_p\| + c\bigr)},\qquad c\approx\sqrt{\tfrac{k}{\rho_0}},
$$
with Courant number \(C\in[0.2,0.5]\) in practice.

<br />

## GPU Frustum Culling (Math)

Each camera frustum plane is \(\pi: \mathbf{n}\cdot\mathbf{x}+d=0\). For a particle sphere \((\mathbf{x}_p, r)\), visibility requires for all planes
$$ \mathbf{n}\cdot\mathbf{x}_p + d \ge -r. $$
We extract planes from the rows of \(\mathbf{M}=\mathbf{P}\mathbf{V}\) (clip‑space matrix) and normalize them. The compute shader writes 1/0 into a visibility buffer, which the renderer uses to discard off‑screen instances.

<br />

### Interactive: View Frustum vs Sphere Visibility

<iframe src="media/post9/frustum.html" width="100%" height="420" style="border:0"></iframe>

<br />

## Screen‑Space Sphere Rendering

In the fragment shader we reconstruct a ray through the pixel and intersect a sphere centered at the projected particle position. For a ray \(\mathbf{o}+t\mathbf{d}\) and sphere \((\mathbf{c},r)\), solve
$$
\|\mathbf{o}+t\mathbf{d}-\mathbf{c}\|^2=r^2 \;\Rightarrow\; at^2+bt+c=0,
$$
with \(a=\mathbf{d}\cdot\mathbf{d},\ b=2\mathbf{d}\cdot(\mathbf{o}-\mathbf{c}),\ c=\|\mathbf{o}-\mathbf{c}\|^2-r^2\). Pick the smallest positive root, compute the surface normal, shade, and write the correct depth so spheres occlude properly.

<br />

## End‑to‑End Flow (One Frame)

```text
[Particles]
   │     P2G (mass, momentum, stress)
   ▼
[Grid]  + forces + viscosity + gravity + BCs
   │     explicit integrate velocities
   ▼
[Particles]  G2P (PIC + affine), advect positions
```

<br />

## Rendering

Particles are drawn as screen‑space spheres using a single instanced draw call. A small triangle list per instance expands into a spherical footprint in the fragment shader, which computes depth and shading for a smooth round appearance. Two visualization modes:

- Wireframe: draws a lightweight proxy for performance debugging
- Solid spheres: shaded impostors with depth testing

An alpha‑blended bounding box can be toggled to visualize the simulation domain.

<br />

## Moving Wall + Dynamic Box

The domain’s Z‑extent can oscillate over time to create a traveling “wave wall” that compresses and releases the fluid. The amplitude is adjustable in the UI; when enabled, the simulator updates a `box_size` uniform every frame and reconfigures the internal grid so particles collide with the moving boundary.

<br />

## Controls

- Simulation: Pause/Resume, Substeps (1–4), “Add 10,000 Particles”
- Wave Controls: Enable/Disable moving wall, Amplitude slider
- Camera: `orbit` (trackball) or `coolcal` (free‑fly with pointer lock; WASD + Space/C)
- Rendering: “potato friendly mode” (wireframe), Show Bounding Box, Resolution Scale, Enable Frustum Culling

Keyboard shortcuts:

- `P` — toggle pause
- `G` — inject +10k particles

<br />

## Pseudocode Snapshot (per frame)

```text
// Simulation step (optional if paused), often with N substeps
for substep in 1..N:
  clearGrid<<<grid>>>()
  p2g1<<<particles>>>()
  p2g2<<<particles>>>()
  updateGrid<<<grid>>>()
  g2p<<<particles>>>()

// Upload camera + domain uniforms
write(renderUniforms)

// Culling + Drawing
cullParticles<<<particles>>>(planes(P*V))
drawParticlesInstanced(visibility)
```

<br />

## Compact Derivations (Sketches)

1) Weak form → P2G internal force
Multiply momentum PDE by a test function \(N_i\) and integrate:
$$
\int_{\Omega} \rho\,\frac{\mathrm{D}\mathbf{v}}{\mathrm{D}t} N_i\,\mathrm{d}V
= \int_{\Omega} (\nabla\cdot\boldsymbol{\sigma}) N_i\,\mathrm{d}V + \int_{\Omega} \rho\,\mathbf{g}N_i\,\mathrm{d}V.
$$
Use divergence theorem on the stress term:
$$
\int_{\Omega} (\nabla\cdot\boldsymbol{\sigma})N_i\,\mathrm{d}V
= -\int_{\Omega} \boldsymbol{\sigma}:\nabla N_i\,\mathrm{d}V
\; + \;\int_{\partial\Omega} (\boldsymbol{\sigma}\,\mathbf{n}) N_i\,\mathrm{d}S.
$$
With fixed or traction‑free walls, the boundary integral vanishes. Approximating the volume integral by particles gives
$$
\mathbf{f}_{i}^{\,\text{int}} \;=\; -\sum_{p} V_p\,\boldsymbol{\sigma}_p\,\nabla N_i(\mathbf{x}_p),
$$
which leads directly to the P2G force used in the code.

2) APIC affine fit
Fit an affine field \(\mathbf{v}(\mathbf{x})\approx\mathbf{v}_p+\mathbf{C}_p(\mathbf{x}-\mathbf{x}_p)\) to grid samples by minimizing
$$
\min_{\mathbf{v}_p,\,\mathbf{C}_p} \sum_i N_i(\mathbf{x}_p)\,\big\|\,\mathbf{v}_i-\big(\mathbf{v}_p+\mathbf{C}_p(\mathbf{x}_i-\mathbf{x}_p)\big)\big\|^2.
$$
Holding \(\mathbf{v}_p\) fixed and differentiating w.r.t. \(\mathbf{C}_p\) yields the normal equations
$$
\mathbf{B}_p = \sum_i N_i\,\mathbf{v}_i(\mathbf{x}_i-\mathbf{x}_p)^{\!T},\qquad
\mathbf{D}_p = \sum_i N_i\,(\mathbf{x}_i-\mathbf{x}_p)(\mathbf{x}_i-\mathbf{x}_p)^{\!T},\qquad
\mathbf{C}_p = \mathbf{B}_p\,\mathbf{D}_p^{-1}.
$$

3) Quadratic B‑spline derivative (1D piecewise)
For \(a=\tfrac{x-x_i}{\Delta x}\):
$$
w_1(a)=0.75-a^2,\quad w_1'(a)=-2a \ (|a|<0.5);\qquad
w_0(a)=\tfrac{1}{2}(1.5-a)^2,\quad w_0'(a)=-(1.5-a) \ (0.5\le a<1.5),
$$
and \(w_2'(a)=+(a-1.5)\) on \(0.5\le a<1.5\). In 3D, apply the product rule and scale by \(1/\Delta x\).

4) CFL bound (heuristic)
For advection and weak compressibility, require information (advection speed + sound speed) not to cross more than one cell per step:
$$
\Delta t \lesssim C\,\frac{\Delta x}{\max_p(\|\mathbf{v}_p\|+c)},\qquad c\approx\sqrt{k/\rho_0}.
$$

5) Frustum planes from clip matrix
Let \(\mathbf{M}=\mathbf{P}\mathbf{V}\). The six planes are rows combinations:
$$
\begin{aligned}
\pi_\text{left}&: \; \mathbf{M}_{4\,*}+\mathbf{M}_{1\,*}, &
\pi_\text{right}&: \; \mathbf{M}_{4\,*}-\mathbf{M}_{1\,*},\\
\pi_\text{bottom}&: \; \mathbf{M}_{4\,*}+\mathbf{M}_{2\,*}, &
\pi_\text{top}&: \; \mathbf{M}_{4\,*}-\mathbf{M}_{2\,*},\\
\pi_\text{near}&: \; \mathbf{M}_{4\,*}+\mathbf{M}_{3\,*}, &
\pi_\text{far}&: \; \mathbf{M}_{4\,*}-\mathbf{M}_{3\,*}.
\end{aligned}
$$
Normalize each \((\mathbf{n},d)\) so \(\|\mathbf{n}\|=1\).

6) Ray–sphere intersection
Solve \(\|\mathbf{o}+t\mathbf{d}-\mathbf{c}\|^2=r^2\Rightarrow at^2+bt+c=0\) with
\(a=\mathbf{d}\cdot\mathbf{d},\ b=2\mathbf{d}\cdot(\mathbf{o}-\mathbf{c}),\ c=\|\mathbf{o}-\mathbf{c}\|^2-r^2\). The smaller positive root is the front intersection.

<br />

## Notes and Future Work

- Add surface reconstruction (e.g., screen‑space curvature/foam cues or marching cubes for meshes)
- Hybrid PIC/FLIP style momentum transfer for different fluid “feel”
- Tiled neighbor search for contact effects and splashes
- Multi‑draw indirect using a prefix‑sum of `visibility` for perfect compaction

If WebGPU isn’t available, use a Chromium‑based browser with WebGPU enabled.
    </script>

    <script src="bob.js"></script>
  </body>
</html>
